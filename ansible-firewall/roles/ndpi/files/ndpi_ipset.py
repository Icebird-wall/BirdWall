#!/usr/bin/env python3
"""Create ipsets for nDPI classified traffic.

The script reads a YAML firewall configuration and ensures that an
ipset exists for every nDPI application or category referenced in
``firewall_cfg.dscp_classes.*.match.ndpi_sets``.

The dictionary ``NDPI_MAP`` maps each nDPI classification name exactly as
spelled in the configuration to the corresponding ipset name.  Ipset
names are generated by sanitising the classification string so they
contain only lowercase alphanumerics and underscores.
"""

import argparse
import re
import subprocess
import sys
from pathlib import Path

import yaml

# Map of nDPI application/category names to ipset identifiers.
# Entries are populated dynamically from the firewall configuration so
# every referenced nDPI set has a corresponding ipset name.
NDPI_MAP = {}

_sanitize_re = re.compile(r"[^a-zA-Z0-9_]")


def sanitize(name: str) -> str:
    """Return a safe ipset name derived from *name*."""
    return _sanitize_re.sub("_", name).lower()


def update_ndpi_map(cfg: dict) -> None:
    """Populate :data:`NDPI_MAP` from a firewall configuration."""
    classes = cfg.get("firewall_cfg", {}).get("dscp_classes", {})
    for cls in classes.values():
        ndpi_sets = cls.get("match", {}).get("ndpi_sets", [])
        for ndpi in ndpi_sets:
            NDPI_MAP.setdefault(ndpi, sanitize(ndpi))


def ensure_ipsets() -> None:
    """Create all ipsets defined in :data:`NDPI_MAP`."""
    for ipset in NDPI_MAP.values():
        subprocess.run(
            ["ipset", "create", ipset, "hash:ip", "family", "inet", "timeout", "0", "-exist"],
            check=True,
        )


def main() -> None:
    parser = argparse.ArgumentParser(description="Create nDPI ipsets from firewall config")
    parser.add_argument("config", type=Path, help="Path to YAML file containing firewall_cfg")
    args = parser.parse_args()

    with args.config.open() as fh:
        cfg = yaml.safe_load(fh)

    update_ndpi_map(cfg)
    ensure_ipsets()


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        sys.exit(1)
